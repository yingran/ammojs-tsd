
            declare namespace Ammo { 

                export class btRigidBody { 

                    constructor( mass?: any, motionState?: btMotionState, collisionShape?: btCollisionShape, localInertia?: btVector3, 0?: any, 0?: any ); 

                    m_contactSolverType: number; 
m_frictionSolverType: number; 
m_deltaLinearVelocity: btVector3; 
m_deltaAngularVelocity: btVector3; 
m_angularFactor: btVector3; 
m_invMass: btVector3; 
m_pushVelocity: btVector3; 
m_turnVelocity: btVector3; 
m_worldTransform: btTransform; 
m_interpolationWorldTransform: btTransform; 
m_interpolationLinearVelocity: btVector3; 
m_interpolationAngularVelocity: btVector3; 
m_anisotropicFriction: btVector3; 
m_hasAnisotropicFriction: number; 
m_contactProcessingThreshold: any; 
m_broadphaseHandle: btBroadphaseProxy; 
m_collisionShape: btCollisionShape; 
m_extensionPointer: any; 
m_rootCollisionShape: btCollisionShape; 
m_collisionFlags: number; 
m_islandTag1: number; 
m_companionId: number; 
m_activationState1: number; 
m_deactivationTime: any; 
m_friction: any; 
m_restitution: any; 
m_rollingFriction: any; 
m_internalType: number; 
m_userObjectPointer: any; 
m_userIndex: number; 
m_hitFraction: any; 
m_ccdSweptSphereRadius: any; 
m_ccdMotionThreshold: any; 
m_checkCollideWith: number; 
m_objectsWithoutCollisionCheck: any; 
m_updateRevision: number; 
m_invInertiaTensorWorld: btMatrix3x3; 
m_linearVelocity: btVector3; 
m_angularVelocity: btVector3; 
m_inverseMass: any; 
m_linearFactor: btVector3; 
m_gravity: btVector3; 
m_gravity_acceleration: btVector3; 
m_invInertiaLocal: btVector3; 
m_totalForce: btVector3; 
m_totalTorque: btVector3; 
m_linearDamping: any; 
m_angularDamping: any; 
m_additionalDamping: boolean; 
m_additionalDampingFactor: any; 
m_additionalLinearDampingThresholdSqr: any; 
m_additionalAngularDampingThresholdSqr: any; 
m_additionalAngularDampingFactor: any; 
m_linearSleepingThreshold: any; 
m_angularSleepingThreshold: any; 
m_optionalMotionState: btMotionState; 
m_constraintRefs: any; 
m_rigidbodyFlags: number; 
m_debugBodyId: number; 
 

                    proceedToTransform( newTrans?: btTransform ): void; 
predictIntegratedTransform( step?: any, predictedTransform?: btTransform ): void; 
saveKinematicState( step?: any ): void; 
applyGravity(  ): void; 
setGravity( acceleration?: btVector3 ): void; 
getGravity(  ): btVector3; 
setDamping( lin_damping?: any, ang_damping?: any ): void; 
getLinearDamping(  ): any; 
getAngularDamping(  ): any; 
getLinearSleepingThreshold(  ): any; 
getAngularSleepingThreshold(  ): any; 
applyDamping( timeStep?: any ): void; 
getCollisionShape(  ): btCollisionShape; 
getCollisionShape(  ): btCollisionShape; 
setMassProps( mass?: any, inertia?: btVector3 ): void; 
getLinearFactor(  ): btVector3; 
setLinearFactor( linearFactor?: btVector3 ): void; 
getInvMass(  ): any; 
getInvInertiaTensorWorld(  ): btMatrix3x3; 
integrateVelocities( step?: any ): void; 
setCenterOfMassTransform( xform?: btTransform ): void; 
applyCentralForce( force?: btVector3 ): void; 
getTotalForce(  ): btVector3; 
getTotalTorque(  ): btVector3; 
getInvInertiaDiagLocal(  ): btVector3; 
setInvInertiaDiagLocal( diagInvInertia?: btVector3 ): void; 
setSleepingThresholds( linear?: any, angular?: any ): void; 
applyTorque( torque?: btVector3 ): void; 
applyForce( force?: btVector3, rel_pos?: btVector3 ): void; 
applyCentralImpulse( impulse?: btVector3 ): void; 
applyTorqueImpulse( torque?: btVector3 ): void; 
applyImpulse( impulse?: btVector3, rel_pos?: btVector3 ): void; 
clearForces(  ): void; 
updateInertiaTensor(  ): void; 
getCenterOfMassPosition(  ): btVector3; 
getOrientation(  ): btQuaternion; 
getCenterOfMassTransform(  ): btTransform; 
getLinearVelocity(  ): btVector3; 
getAngularVelocity(  ): btVector3; 
setLinearVelocity( lin_vel?: btVector3 ): void; 
setAngularVelocity( ang_vel?: btVector3 ): void; 
getVelocityInLocalPoint( rel_pos?: btVector3 ): btVector3; 
translate( v?: btVector3 ): void; 
getAabb( aabbMin?: btVector3, aabbMax?: btVector3 ): void; 
computeImpulseDenominator( pos?: btVector3, normal?: btVector3 ): any; 
computeAngularImpulseDenominator( axis?: btVector3 ): any; 
updateDeactivation( timeStep?: any ): void; 
wantsSleeping(  ): boolean; 
getBroadphaseProxy(  ): btBroadphaseProxy; 
getBroadphaseProxy(  ): btBroadphaseProxy; 
setNewBroadphaseProxy( broadphaseProxy?: btBroadphaseProxy ): void; 
getMotionState(  ): btMotionState; 
getMotionState(  ): btMotionState; 
setMotionState( motionState?: btMotionState ): void; 
setAngularFactor( angFac?: btVector3 ): void; 
setAngularFactor( angFac?: any ): void; 
getAngularFactor(  ): btVector3; 
isInWorld(  ): boolean; 
addConstraintRef( c?: btTypedConstraint ): void; 
removeConstraintRef( c?: btTypedConstraint ): void; 
getConstraintRef( index?: number ): btTypedConstraint; 
getNumConstraintRefs(  ): number; 
setFlags( flags?: number ): void; 
getFlags(  ): number; 
computeGyroscopicImpulseImplicit_World( dt?: any ): btVector3; 
computeGyroscopicImpulseImplicit_Body( step?: any ): btVector3; 
computeGyroscopicForceExplicit( maxGyroscopicForce?: any ): btVector3; 
getLocalInertia(  ): btVector3; 
calculateSerializeBufferSize(  ): number; 
serialize( dataBuffer?: void, serializer?: btSerializer ): any; 
serializeSingleObject( serializer?: btSerializer ): void; 
BT_DECLARE_ALIGNED_ALLOCATOR(  ): any; 
mergesSimulationIslands(  ): boolean; 
getAnisotropicFriction(  ): btVector3; 
setAnisotropicFriction( anisotropicFriction?: btVector3, frictionMode?: number ): void; 
hasAnisotropicFriction( frictionMode?: number ): boolean; 
setContactProcessingThreshold( contactProcessingThreshold?: any ): void; 
getContactProcessingThreshold(  ): any; 
isStaticObject(  ): boolean; 
isKinematicObject(  ): boolean; 
isStaticOrKinematicObject(  ): boolean; 
hasContactResponse(  ): boolean; 
btCollisionObject(  ): any; 
btCollisionObject(  ): any; 
setCollisionShape( collisionShape?: btCollisionShape ): void; 
getCollisionShape(  ): btCollisionShape; 
getCollisionShape(  ): btCollisionShape; 
setIgnoreCollisionCheck( co?: btCollisionObject, ignoreCollisionCheck?: boolean ): void; 
checkCollideWithOverride( co?: btCollisionObject ): boolean; 
internalGetExtensionPointer(  ): any; 
internalSetExtensionPointer( pointer?: void ): void; 
getActivationState(  ): number; 
setActivationState( newState?: number ): void; 
setDeactivationTime( time?: any ): void; 
getDeactivationTime(  ): any; 
forceActivationState( newState?: number ): void; 
activate( forceActivation?: boolean ): void; 
isActive(  ): boolean; 
setRestitution( rest?: any ): void; 
getRestitution(  ): any; 
setFriction( frict?: any ): void; 
getFriction(  ): any; 
setRollingFriction( frict?: any ): void; 
getRollingFriction(  ): any; 
getInternalType(  ): number; 
getWorldTransform(  ): btTransform; 
getWorldTransform(  ): btTransform; 
setWorldTransform( worldTrans?: btTransform ): void; 
getBroadphaseHandle(  ): btBroadphaseProxy; 
getBroadphaseHandle(  ): btBroadphaseProxy; 
setBroadphaseHandle( handle?: btBroadphaseProxy ): void; 
getInterpolationWorldTransform(  ): btTransform; 
getInterpolationWorldTransform(  ): btTransform; 
setInterpolationWorldTransform( trans?: btTransform ): void; 
setInterpolationLinearVelocity( linvel?: btVector3 ): void; 
setInterpolationAngularVelocity( angvel?: btVector3 ): void; 
getInterpolationLinearVelocity(  ): btVector3; 
getInterpolationAngularVelocity(  ): btVector3; 
getIslandTag(  ): number; 
setIslandTag( tag?: number ): void; 
getCompanionId(  ): number; 
setCompanionId( id?: number ): void; 
getHitFraction(  ): any; 
setHitFraction( hitFraction?: any ): void; 
getCollisionFlags(  ): number; 
setCollisionFlags( flags?: number ): void; 
getCcdSweptSphereRadius(  ): any; 
setCcdSweptSphereRadius( radius?: any ): void; 
getCcdMotionThreshold(  ): any; 
getCcdSquareMotionThreshold(  ): any; 
setCcdMotionThreshold( ccdMotionThreshold?: any ): void; 
getUserPointer(  ): any; 
getUserIndex(  ): number; 
setUserPointer( userPointer?: void ): void; 
setUserIndex( index?: number ): void; 
getUpdateRevisionInternal(  ): number; 
checkCollideWith( co?: btCollisionObject ): boolean; 
setupRigidBody( constructionInfo?: btRigidBodyConstructionInfo ): void; 
 

                } 

            }
        