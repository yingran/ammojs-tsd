
            declare namespace Ammo { 

                export class btSliderConstraint { 

                    constructor( rbA?: btRigidBody, rbB?: btRigidBody, frameInA?: btTransform, frameInB?: btTransform, useLinearReferenceFrameA?: boolean ); 

                    m_useSolveConstraintObsolete: boolean; 
m_useOffsetForConstraintFrame: boolean; 
m_frameInA: btTransform; 
m_frameInB: btTransform; 
m_useLinearReferenceFrameA: boolean; 
m_lowerLinLimit: any; 
m_upperLinLimit: any; 
m_lowerAngLimit: any; 
m_upperAngLimit: any; 
m_softnessDirLin: any; 
m_restitutionDirLin: any; 
m_dampingDirLin: any; 
m_cfmDirLin: any; 
m_softnessDirAng: any; 
m_restitutionDirAng: any; 
m_dampingDirAng: any; 
m_cfmDirAng: any; 
m_softnessLimLin: any; 
m_restitutionLimLin: any; 
m_dampingLimLin: any; 
m_cfmLimLin: any; 
m_softnessLimAng: any; 
m_restitutionLimAng: any; 
m_dampingLimAng: any; 
m_cfmLimAng: any; 
m_softnessOrthoLin: any; 
m_restitutionOrthoLin: any; 
m_dampingOrthoLin: any; 
m_cfmOrthoLin: any; 
m_softnessOrthoAng: any; 
m_restitutionOrthoAng: any; 
m_dampingOrthoAng: any; 
m_cfmOrthoAng: any; 
m_solveLinLim: boolean; 
m_solveAngLim: boolean; 
m_flags: number; 
m_jacLin: btJacobianEntry; 
m_jacLinDiagABInv: any; 
m_jacAng: btJacobianEntry; 
m_timeStep: any; 
m_calculatedTransformA: btTransform; 
m_calculatedTransformB: btTransform; 
m_sliderAxis: btVector3; 
m_realPivotAInW: btVector3; 
m_realPivotBInW: btVector3; 
m_projPivotInW: btVector3; 
m_delta: btVector3; 
m_depth: btVector3; 
m_relPosA: btVector3; 
m_relPosB: btVector3; 
m_linPos: any; 
m_angPos: any; 
m_angDepth: any; 
m_kAngle: any; 
m_poweredLinMotor: boolean; 
m_targetLinMotorVelocity: any; 
m_maxLinMotorForce: any; 
m_accumulatedLinMotorImpulse: any; 
m_poweredAngMotor: boolean; 
m_targetAngMotorVelocity: any; 
m_maxAngMotorForce: any; 
m_accumulatedAngMotorImpulse: any; 
m_rbA: btRigidBody; 
m_rbB: btRigidBody; 
m_appliedImpulse: any; 
m_dbgDrawSize: any; 
m_jointFeedback: btJointFeedback; 
 

                    BT_DECLARE_ALIGNED_ALLOCATOR(  ): any; 
getInfo1( info?: btConstraintInfo1 ): void; 
getInfo1NonVirtual( info?: btConstraintInfo1 ): void; 
getInfo2( info?: btConstraintInfo2 ): void; 
getInfo2NonVirtual( info?: btConstraintInfo2, transA?: btTransform, transB?: btTransform, linVelA?: btVector3, linVelB?: btVector3, rbAinvMass?: any, rbBinvMass?: any ): void; 
getRigidBodyA(  ): btRigidBody; 
getRigidBodyB(  ): btRigidBody; 
getCalculatedTransformA(  ): btTransform; 
getCalculatedTransformB(  ): btTransform; 
getFrameOffsetA(  ): btTransform; 
getFrameOffsetB(  ): btTransform; 
getFrameOffsetA(  ): btTransform; 
getFrameOffsetB(  ): btTransform; 
getLowerLinLimit(  ): any; 
setLowerLinLimit( lowerLimit?: any ): void; 
getUpperLinLimit(  ): any; 
setUpperLinLimit( upperLimit?: any ): void; 
getLowerAngLimit(  ): any; 
setLowerAngLimit( lowerLimit?: any ): void; 
getUpperAngLimit(  ): any; 
setUpperAngLimit( upperLimit?: any ): void; 
getUseLinearReferenceFrameA(  ): boolean; 
getSoftnessDirLin(  ): any; 
getRestitutionDirLin(  ): any; 
getDampingDirLin(  ): any; 
getSoftnessDirAng(  ): any; 
getRestitutionDirAng(  ): any; 
getDampingDirAng(  ): any; 
getSoftnessLimLin(  ): any; 
getRestitutionLimLin(  ): any; 
getDampingLimLin(  ): any; 
getSoftnessLimAng(  ): any; 
getRestitutionLimAng(  ): any; 
getDampingLimAng(  ): any; 
getSoftnessOrthoLin(  ): any; 
getRestitutionOrthoLin(  ): any; 
getDampingOrthoLin(  ): any; 
getSoftnessOrthoAng(  ): any; 
getRestitutionOrthoAng(  ): any; 
getDampingOrthoAng(  ): any; 
setSoftnessDirLin( softnessDirLin?: any ): void; 
setRestitutionDirLin( restitutionDirLin?: any ): void; 
setDampingDirLin( dampingDirLin?: any ): void; 
setSoftnessDirAng( softnessDirAng?: any ): void; 
setRestitutionDirAng( restitutionDirAng?: any ): void; 
setDampingDirAng( dampingDirAng?: any ): void; 
setSoftnessLimLin( softnessLimLin?: any ): void; 
setRestitutionLimLin( restitutionLimLin?: any ): void; 
setDampingLimLin( dampingLimLin?: any ): void; 
setSoftnessLimAng( softnessLimAng?: any ): void; 
setRestitutionLimAng( restitutionLimAng?: any ): void; 
setDampingLimAng( dampingLimAng?: any ): void; 
setSoftnessOrthoLin( softnessOrthoLin?: any ): void; 
setRestitutionOrthoLin( restitutionOrthoLin?: any ): void; 
setDampingOrthoLin( dampingOrthoLin?: any ): void; 
setSoftnessOrthoAng( softnessOrthoAng?: any ): void; 
setRestitutionOrthoAng( restitutionOrthoAng?: any ): void; 
setDampingOrthoAng( dampingOrthoAng?: any ): void; 
setPoweredLinMotor( onOff?: boolean ): void; 
getPoweredLinMotor(  ): boolean; 
setTargetLinMotorVelocity( targetLinMotorVelocity?: any ): void; 
getTargetLinMotorVelocity(  ): any; 
setMaxLinMotorForce( maxLinMotorForce?: any ): void; 
getMaxLinMotorForce(  ): any; 
setPoweredAngMotor( onOff?: boolean ): void; 
getPoweredAngMotor(  ): boolean; 
setTargetAngMotorVelocity( targetAngMotorVelocity?: any ): void; 
getTargetAngMotorVelocity(  ): any; 
setMaxAngMotorForce( maxAngMotorForce?: any ): void; 
getMaxAngMotorForce(  ): any; 
getLinearPos(  ): any; 
getAngularPos(  ): any; 
getSolveLinLimit(  ): boolean; 
getLinDepth(  ): any; 
getSolveAngLimit(  ): boolean; 
getAngDepth(  ): any; 
calculateTransforms( transA?: btTransform, transB?: btTransform ): void; 
testLinLimits(  ): void; 
testAngLimits(  ): void; 
getAncorInA(  ): btVector3; 
getAncorInB(  ): btVector3; 
getUseFrameOffset(  ): boolean; 
setUseFrameOffset( frameOffsetOnOff?: boolean ): void; 
setFrames( frameA?: btTransform, frameB?: btTransform ): void; 
setParam( num?: number, value?: any, axis?: number ): void; 
getParam( num?: number, axis?: number ): any; 
calculateSerializeBufferSize(  ): number; 
serialize( dataBuffer?: void, serializer?: btSerializer ): any; 
BT_DECLARE_ALIGNED_ALLOCATOR(  ): any; 
btTypedConstraint(  ): any; 
btTypedConstraint( type?: btTypedConstraintType, rbA?: btRigidBody ): any; 
btTypedConstraint( type?: btTypedConstraintType, rbA?: btRigidBody, rbB?: btRigidBody ): any; 
getOverrideNumSolverIterations(  ): number; 
setOverrideNumSolverIterations( overideNumIterations?: number ): void; 
buildJacobian(  ): void; 
setupSolverConstraint( ca?: btConstraintArray, solverBodyA?: number, solverBodyB?: number, timeStep?: any ): void; 
internalSetAppliedImpulse( appliedImpulse?: any ): void; 
internalGetAppliedImpulse(  ): any; 
getBreakingImpulseThreshold(  ): any; 
setBreakingImpulseThreshold( threshold?: any ): void; 
isEnabled(  ): boolean; 
setEnabled( enabled?: boolean ): void; 
solveConstraintObsolete( arg1?: btSolverBody, arg2?: btSolverBody, btScalar?: any ): void; 
getRigidBodyA(  ): btRigidBody; 
getRigidBodyB(  ): btRigidBody; 
getRigidBodyA(  ): btRigidBody; 
getRigidBodyB(  ): btRigidBody; 
getUserConstraintType(  ): number; 
setUserConstraintType( userConstraintType?: number ): void; 
setUserConstraintId( uid?: number ): void; 
getUserConstraintId(  ): number; 
setUserConstraintPtr( ptr?: void ): void; 
getUserConstraintPtr(  ): any; 
setJointFeedback( jointFeedback?: btJointFeedback ): void; 
getJointFeedback(  ): btJointFeedback; 
getJointFeedback(  ): btJointFeedback; 
getUid(  ): number; 
needsFeedback(  ): boolean; 
enableFeedback( needsFeedback?: boolean ): void; 
getAppliedImpulse(  ): any; 
getConstraintType(  ): btTypedConstraintType; 
setDbgDrawSize( dbgDrawSize?: any ): void; 
getDbgDrawSize(  ): any; 
btTypedObject( objectType?: number ): any; 
getObjectType(  ): number; 
initParams(  ): void; 
getMotorFactor( pos?: any, lowLim?: any, uppLim?: any, vel?: any, timeFact?: any ): any; 
 

                } 

            }
        